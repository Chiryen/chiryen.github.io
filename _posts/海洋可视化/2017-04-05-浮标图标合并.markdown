---
layout: post
title:  "浮标图标合并(并查集)"
categories: 海洋可视化
---

## 浮标图标合并
在项目中有一项需求是在三维空间中，视点移动，地球上浮标的图标在屏幕上的位置会发生变化，多个浮标可能发生重叠，重叠的浮标图标上需要显示重叠浮标的个数。浮标图标为正方形，当两个图标，比如图标A、B,<font color='red'>条件:A和B的横坐标之差与纵坐标之差同时小于正方形的边长</font>时，图标就会重叠。问题转化为平面内的点集，满足条件的点集归为一类，A和B为一类，B和C也为一类，那么A和C也同为一类。此类问题适合用并查集解决。   
项目里每个浮标都有一个名称name, 为string类型。在update()过程中，也就是每次draw()之前，去建立满足条件的点的关系。

	pair<string, string> pair;
	for (std::map<std::string, BattlefieldObject*>::iterator it = _battlefield_object_map.begin(); it != _battlefield_object_map.end(); ++it)
	{
		float overlayWidth = it->second->_overlay2D->width;
		float overlayHeight = it->second->_overlay2D->hight;
		vec4d pos1 = it->second->_overlay2D->screenpos_normal;
		for (std::map<std::string, BattlefieldObject*>::iterator ii = it; ii != _battlefield_object_map.end(); ++ii)
		{
			if(it != ii)
			{
				vec4d pos2 = ii->second->_overlay2D->screenpos_normal;
				
				if( (fabs(pos1.x-pos2.x)*FrameBufferWidth)/2<overlayWidth && 
					(fabs(pos1.y-pos2.y)*FrameBufferHeight)/2<overlayHeight )
				{	//正规化范围为-1.0~1.0，所以要除以2
					//_match_pair[it->first] = ii->first;
					temp_pair.first = it->first;
					temp_pair.second = ii->first;
					_match_pair.push_back(temp_pair);
				}
			}
		}
	}

_match_pair的数据类型为vector<pair<string, string>>,它存储的是所有点的关联信息。这样便得到了并查集的构造条件。然后按照[How Many Tables](https://chiryen.github.io/jekyll/update/2017/03/26/How-Many-Tables.html)中的三步走。  


	UnionFindSet::UnionFindSet(vector<pair<string, string>> match_pair, map<string, BattlefieldObject*> battlefield_object_map)
	{
		_match_pair = match_pair;
		for (map<string, BattlefieldObject*>::iterator it = battlefield_object_map.begin(); it != battlefield_object_map.end(); ++it)
		{
			_set[it->first] = it->first;
		}
	}
	
	string UnionFindSet::findRoot(string str)
	{
		if(str != _set[str])
			_set[str] = findRoot(_set[str]);
		return _set[str];
	}
	
	void UnionFindSet::Union(string x, string y)
	{
		string rootx = findRoot(x);
		string rooty = findRoot(y);
		if(rootx != rooty)
			_set[rooty] = rootx;
	}
	
	map<string, string> UnionFindSet::getSet()
	{
		for (vector<pair<string, string>>::iterator it = _match_pair.begin(); it != _match_pair.end(); ++it)
		{
			Union(it->first, it->second);
		}
		for (map<string, string>::iterator it = _set.begin(); it != _set.end(); ++it)
		{
			findRoot(it->first);
		}
	
		return _set;
	}
	map<string, vector<string>> UnionFindSet::getMap()
	{
		getSet();
		rootmap.clear();
		for (map<string, string>::iterator it = _set.begin(); it != _set.end(); ++it)
		{
			rootmap[it->second].push_back(it->first);
		}
		return rootmap;
	}


make-set操作在构造函数中完成的，find操作这里采用的是递归的方式，在union操作后并不是每个结点的父节点都是根节点，可以使用路径压缩来完成，这里是将所有的点在findRoot()一遍,这样所有点的_set[x]都是对应树的根节点。